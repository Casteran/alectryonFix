.alectryon-io, .alectryon-toggle-label {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
    overflow: visible;
    overflow-wrap: break-word;
    position: relative;
    white-space: pre-wrap;
}

/*
CoqIDE doesn't turn off the unicode bidirectional algorithm (and PG simply
respects the user's `bidi-display-reordering` setting), so don't turn it off
here either.  But beware unexpected results like `Definition test_אב := 0.`

.alectryon-io span {
    direction: ltr;
    unicode-bidi: bidi-override;
}

In any case, make an exception for comments:

.highlight .c {
    direction: embed;
    unicode-bidi: initial;
}
*/

.alectryon-toggle,
.alectryon-io .coq-toggle {
    display: none;
}

.alectryon-toggle-label,
.alectryon-io .coq-sentence[for] {
    cursor: pointer;
    padding: 0.1em 0; /* Enlarge the hitbox slightly to fill interline gaps */
    padding-right: 1rem; /* Prevent wraps before the bubble */
}

.alectryon-toggle-label {
    display: block;
    font-size: 0.8rem;
}

.alectryon-toggle-label:before,
.alectryon-io .coq-sentence[for]:after {
    border: 1px solid #babdb6;
    border-radius: 1rem;
    content: '';
    display: inline-block;
    font-weight: bold;
    height: 0.25rem;
    margin-bottom: 0.15rem;
    vertical-align: middle;
    width: 0.75rem;
}

.alectryon-toggle-label:before {
    margin-right: 0.25rem;
}

.alectryon-io .coq-sentence[for]:after {
    margin-left: 0.25rem;
    margin-right: -1rem; /* Compensate for the anti-wrapping space */
}

@media (any-hover: hover) {
    .alectryon-toggle-label:hover:before,
    .alectryon-io .coq-sentence[for]:hover:after {
        background: #eeeeec;
    }

    .alectryon-io .coq-fragment .coq-sentence[for]:hover {
        text-decoration: underline dotted #babdb6;
    }

    .alectryon-io .coq-fragment .coq-sentence[for]:hover * {
        font-weight: bold;
    }

    .alectryon-io .coq-fragment:hover .coq-output:not(:hover) {
        display: block;
    }
}

.alectryon-toggle:checked + .alectryon-toggle-label:before,
.alectryon-io .coq-toggle:checked + .coq-sentence[for]:after {
    background-color: #babdb6;
    border-color: #babdb6;
}

/* Hide individual checkboxes when the document-wide toggle is set */
.alectryon-toggle:checked ~ .alectryon-io .coq-toggle + .coq-sentence[for]:after {
    display: none;
}

.alectryon-io .coq-output {
    border-width: 1px 0;
    display: none;
    left: 0;
    position: absolute;
    right: 0;
    top: 100%;
    z-index: 1;
}

/* If there's space, display goals to the right of the code, not below it. */
@media screen and (any-hover: hover) and (min-width: 90rem) {
    .alectryon-io {
        box-sizing: border-box; /* Needed so .coq-output won't overflow */
        width: 55%;
    }

    .alectryon-io .coq-output {
        bottom: 0;
        left: 100%;
        margin-top: -0.25rem;
        padding-left: 0.25rem;
        right: unset;
        top: 0;
        width: 81%; /* 81% of .alectryion-io's 55% is ~45% */
    }

    .alectryon-io .coq-output > div {
        /* This odd margin-bottom property prevents the sticky div from bumping
           against the bottom of its container (.coq-output).  The alternative
           would be enlarging .coq-output, but that would cause overflows,
           enlarging scrollbars and yielding scrolling towards the bottom of the
           page.  Doing things this way instead makes it possible to restrict
           .coq-output to a reasonable size (100%, through top = bottom = 0).
           See also https://stackoverflow.com/questions/43909940/. */
        margin-bottom: -200%;
        position: sticky;
        top: 0;
    }
}

.alectryon-io .coq-goals:not(:empty),
.alectryon-io .coq-responses:not(:empty) {
    background: #eeeeec;
    display: block;
    margin: 0.25rem 0;
    padding: 0.25rem;
}

.alectryon-toggle:checked ~ .alectryon-io .coq-sentence[for] + .coq-output,
.alectryon-io .coq-toggle:checked + .coq-sentence[for] + .coq-output {
    display: block;
    position: unset;
    margin: unset;
    padding: unset;
    width: unset;
}

.alectryon-toggle:checked ~ .alectryon-io .coq-sentence[for] + .coq-output > div,
.alectryon-io .coq-toggle:checked + .coq-sentence[for] + .coq-output > div {
    display: block;
    margin-bottom: unset;
}

.alectryon-toggle:checked ~ .alectryon-io .coq-toggle ~ .coq-wsp,
.alectryon-io .coq-toggle:checked ~ .coq-wsp {
    display: none;
}

.alectryon-io .coq-responses,
.alectryon-io .coq-response,
.alectryon-io .coq-goals,
.alectryon-io .coq-goal,
.alectryon-io .goal-hyp,
.alectryon-io .goal-conclusion {
    border-radius: 0.15rem;
}

.alectryon-io .coq-goal,
.alectryon-io .coq-response {
    align-items: center;
    background: #d3d7cf;
    display: block;
    flex-direction: column;
    margin: 0.25rem;
    padding: 0.5rem;
    position: relative;
}

.alectryon-io .goal-name {
    position: absolute;
    right: 0.5rem;
    top: 0.5rem;
}

.alectryon-io .goal-hyps {
    align-content: space-around;
    align-items: baseline;
    display: flex;
    flex-flow: column; /* row wrap? */
    justify-content: space-around;
    margin: -0.15rem -1rem;
}

.alectryon-io .goal-hyp,
.alectryon-io .goal-conclusion {
    background: #eeeeec;
    display: inline-block;
    padding: 0.15rem 0.35rem;
}

.alectryon-io .goal-hyp {
    display: inline-flex;
    margin: 0.15rem 1rem;
    z-index: 1;
}

.alectryon-io .hyp-punct {
    font-weight: bold;
    margin: 0 0.5rem;
}

.alectryon-io .hyp-body,
.alectryon-io .hyp-type {
    display: flex;
    vertical-align: top;
}

.alectryon-io .goal-separator {
    background: #555753;
    border: none;
    display: block;
    height: 1px;
    margin: 0.55rem 0;
    width: 100%;
}
